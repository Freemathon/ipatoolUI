// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/februarysnow/go/pkg/mod/github.com/99designs/go-keychain@v0.0.0-20191008050251-8e49817e8af4/corefoundation.go:1:1
// +build darwin ios

package keychain

/*
#cgo LDFLAGS: -framework CoreFoundation

#include <CoreFoundation/CoreFoundation.h>

// Can't cast a *uintptr to *unsafe.Pointer in Go, and casting
// C.CFTypeRef to unsafe.Pointer is unsafe in Go, so have shim functions to
// do the casting in C (where it's safe).

// We add a suffix to the C functions below, because we copied this
// file from go-kext, which means that any project that depends on this
// package and go-kext would run into duplicate symbol errors otherwise.
//
// TODO: Move this file into its own package depended on by go-kext
// and this package.

CFDictionaryRef CFDictionaryCreateSafe2(CFAllocatorRef allocator, const uintptr_t *keys, const uintptr_t *values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks) {
  return CFDictionaryCreate(allocator, (const void **)keys, (const void **)values, numValues, keyCallBacks, valueCallBacks);
}

CFArrayRef CFArrayCreateSafe2(CFAllocatorRef allocator, const uintptr_t *values, CFIndex numValues, const CFArrayCallBacks *callBacks) {
  return CFArrayCreate(allocator, (const void **)values, numValues, callBacks);
}
*/
import _ "unsafe"
import (
	"errors"
	"fmt"
	"math"
	"reflect"
	"unicode/utf8"
	"unsafe"
)

// Release releases memory pointed to by a CFTypeRef.
func Release(ref  /*line :40:18*/_Ctype_CFTypeRef /*line :40:29*/) {
	func() { var _cgo0 _Ctype_CFTypeRef = /*line :41:14*/ref; /*line :41:18*/_Cfunc_CFRelease(_cgo0); }()
}

// BytesToCFData will return a CFDataRef and if non-nil, must be released with
// Release(ref).
func BytesToCFData(b []byte) ( /*line :46:31*/_Ctype_CFDataRef /*line :46:42*/, error) {
	if uint64(len(b)) > math.MaxUint32 {
		return 0, errors.New("Data is too large")
	}
	var p * /*line :50:9*/_Ctype_UInt8 /*line :50:16*/
	if len(b) > 0 {
		p = (* /*line :52:9*/_Ctype_UInt8 /*line :52:16*/)(&b[0])
	}
	cfData := func() _Ctype_CFDataRef{ var _cgo0 _Ctype_CFAllocatorRef = /*line :54:27*/*_Cvar_kCFAllocatorDefault /*line :54:48*/; var _cgo1 *_Ctype_UInt8 = /*line :54:50*/p; var _cgo2 _Ctype_CFIndex = _Ctype_CFIndex /*line :54:62*/(len(b)); return /*line :54:71*/_Cfunc_CFDataCreate(_cgo0, _cgo1, _cgo2); }()
	if cfData == 0 {
		return 0, fmt.Errorf("CFDataCreate failed")
	}
	return cfData, nil
}

// CFDataToBytes converts CFData to bytes.
func CFDataToBytes(cfData  /*line :62:27*/_Ctype_CFDataRef /*line :62:38*/) ([]byte, error) {
	return func() []byte{ _cgo0 := /*line :63:19*/unsafe.Pointer(func() *_Ctype_UInt8{ var _cgo0 _Ctype_CFDataRef = /*line :63:53*/cfData; return /*line :63:60*/_Cfunc_CFDataGetBytePtr(_cgo0); }()); var _cgo1 _Ctype_int = _Ctype_int /*line :63:68*/(func() _Ctype_CFIndex{ var _cgo0 _Ctype_CFDataRef = /*line :63:87*/cfData; return /*line :63:94*/_Cfunc_CFDataGetLength(_cgo0); }()); _cgoCheckPointer(_cgo0, nil); return /*line :63:96*/_Cfunc_GoBytes(_cgo0, _cgo1); }(), nil
}

// MapToCFDictionary will return a CFDictionaryRef and if non-nil, must be
// released with Release(ref).
func MapToCFDictionary(m map[ /*line :68:30*/_Ctype_CFTypeRef /*line :68:41*/] /*line :68:42*/_Ctype_CFTypeRef /*line :68:53*/) ( /*line :68:56*/_Ctype_CFDictionaryRef /*line :68:73*/, error) {
	var keys, values [] /*line :69:21*/_Ctype_uintptr_t /*line :69:32*/
	for key, value := range m {
		keys = append(keys,  /*line :71:23*/_Ctype_uintptr_t /*line :71:34*/(key))
		values = append(values,  /*line :72:27*/_Ctype_uintptr_t /*line :72:38*/(value))
	}
	numValues := len(values)
	var keysPointer, valuesPointer * /*line :75:34*/_Ctype_uintptr_t /*line :75:45*/
	if numValues > 0 {
		keysPointer = &keys[0]
		valuesPointer = &values[0]
	}
	cfDict := func() _Ctype_CFDictionaryRef{ var _cgo0 _Ctype_CFAllocatorRef = /*line :80:38*/*_Cvar_kCFAllocatorDefault /*line :80:59*/; var _cgo1 *_Ctype_uintptr_t = /*line :80:61*/keysPointer; var _cgo2 *_Ctype_uintptr_t = /*line :80:74*/valuesPointer; var _cgo3 _Ctype_CFIndex = _Ctype_CFIndex /*line :80:98*/(numValues); _cgoBase4 := /*line :81:3*/&*_Cvar_kCFTypeDictionaryKeyCallBacks /*line :81:35*/; _cgo4 := _cgoBase4; _cgoBase5 := /*line :81:37*/&*_Cvar_kCFTypeDictionaryValueCallBacks /*line :81:71*/; _cgo5 := _cgoBase5; _cgoCheckPointer(_cgoBase4, 0 == 0); _cgoCheckPointer(_cgoBase5, 0 == 0); return /*line :81:72*/_Cfunc_CFDictionaryCreateSafe2(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() //nolint
	if cfDict == 0 {
		return 0, fmt.Errorf("CFDictionaryCreate failed")
	}
	return cfDict, nil
}

// CFDictionaryToMap converts CFDictionaryRef to a map.
func CFDictionaryToMap(cfDict  /*line :89:31*/_Ctype_CFDictionaryRef /*line :89:48*/) (m map[ /*line :89:57*/_Ctype_CFTypeRef /*line :89:68*/] /*line :89:69*/_Ctype_CFTypeRef /*line :89:80*/) {
	count := func() _Ctype_CFIndex{ var _cgo0 _Ctype_CFDictionaryRef = /*line :90:34*/cfDict; return /*line :90:41*/_Cfunc_CFDictionaryGetCount(_cgo0); }()
	if count > 0 {
		keys := make([] /*line :92:18*/_Ctype_CFTypeRef /*line :92:29*/, count)
		values := make([] /*line :93:20*/_Ctype_CFTypeRef /*line :93:31*/, count)
		func() { var _cgo0 _Ctype_CFDictionaryRef = /*line :94:34*/cfDict; _cgoIndex1 := &/*line :94:76*/keys; _cgo1 := /*line :94:42*/(*unsafe.Pointer)(unsafe.Pointer(&(*_cgoIndex1)[0])); _cgoIndex2 := &/*line :94:121*/values; _cgo2 := /*line :94:87*/(*unsafe.Pointer)(unsafe.Pointer(&(*_cgoIndex2)[0])); _cgoCheckPointer(_cgo1, *_cgoIndex1); _cgoCheckPointer(_cgo2, *_cgoIndex2); /*line :94:133*/_Cfunc_CFDictionaryGetKeysAndValues(_cgo0, _cgo1, _cgo2); }()
		m = make(map[ /*line :95:16*/_Ctype_CFTypeRef /*line :95:27*/] /*line :95:28*/_Ctype_CFTypeRef /*line :95:39*/, count)
		for i :=  /*line :96:12*/_Ctype_CFIndex /*line :96:21*/(0); i < count; i++ {
			m[keys[i]] = values[i]
		}
	}
	return
}

// StringToCFString will return a CFStringRef and if non-nil, must be released with
// Release(ref).
func StringToCFString(s string) ( /*line :105:34*/_Ctype_CFStringRef /*line :105:47*/, error) {
	if !utf8.ValidString(s) {
		return 0, errors.New("Invalid UTF-8 string")
	}
	if uint64(len(s)) > math.MaxUint32 {
		return 0, errors.New("String is too large")
	}

	bytes := []byte(s)
	var p * /*line :114:9*/_Ctype_UInt8 /*line :114:16*/
	if len(bytes) > 0 {
		p = (* /*line :116:9*/_Ctype_UInt8 /*line :116:16*/)(&bytes[0])
	}
	return func() _Ctype_CFStringRef{ var _cgo0 _Ctype_CFAllocatorRef = /*line :118:35*/*_Cvar_kCFAllocatorDefault /*line :118:56*/; var _cgo1 *_Ctype_UInt8 = /*line :118:58*/p; var _cgo2 _Ctype_CFIndex = _Ctype_CFIndex /*line :118:70*/(len(s)); var _cgo3 _Ctype_CFStringEncoding = /*line :118:80*/_Ciconst_kCFStringEncodingUTF8 /*line :118:103*/; var _cgo4 _Ctype_Boolean = /*line :118:105*/_Ciconst_false /*line :118:112*/; return /*line :118:113*/_Cfunc_CFStringCreateWithBytes(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }(), nil
}

// CFStringToString converts a CFStringRef to a string.
func CFStringToString(s  /*line :122:25*/_Ctype_CFStringRef /*line :122:38*/) string {
	p := func() *_Ctype_char{ var _cgo0 _Ctype_CFStringRef = /*line :123:31*/s; var _cgo1 _Ctype_CFStringEncoding = /*line :123:34*/_Ciconst_kCFStringEncodingUTF8 /*line :123:57*/; return /*line :123:58*/_Cfunc_CFStringGetCStringPtr(_cgo0, _cgo1); }()
	if p != nil {
		return ( /*line :125:10*/_Cfunc_GoString /*line :125:19*/)(p)
	}
	length := func() _Ctype_CFIndex{ var _cgo0 _Ctype_CFStringRef = /*line :127:32*/s; return /*line :127:34*/_Cfunc_CFStringGetLength(_cgo0); }()
	if length == 0 {
		return ""
	}
	maxBufLen := ( /*line :131:15*/_Cfunc_CFStringGetMaximumSizeForEncoding /*line :131:49*/)(length, ( /*line :131:59*/_Ciconst_kCFStringEncodingUTF8 /*line :131:81*/))
	if maxBufLen == 0 {
		return ""
	}
	buf := make([]byte, maxBufLen)
	var usedBufLen  /*line :136:17*/_Ctype_CFIndex /*line :136:26*/
	_ = func() _Ctype_CFIndex{ var _cgo0 _Ctype_CFStringRef = /*line :137:25*/s; var _cgo1 _Ctype_struct___1 = _Ctype_CFRange /*line :137:37*/{0, length}; var _cgo2 _Ctype_CFStringEncoding = /*line :137:50*/_Ciconst_kCFStringEncodingUTF8 /*line :137:73*/; var _cgo3 _Ctype_UInt8 = _Ctype_UInt8 /*line :137:82*/(0); var _cgo4 _Ctype_Boolean = /*line :137:87*/_Ciconst_false /*line :137:94*/; var _cgo5 *_Ctype_UInt8 = /*line :137:96*/(*_Ctype_UInt8 /*line :137:105*/)(&buf[0]); var _cgo6 _Ctype_CFIndex = /*line :137:117*/maxBufLen; var _cgo7 *_Ctype_CFIndex = /*line :137:128*/&usedBufLen; return /*line :137:140*/_Cfunc_CFStringGetBytes(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7); }()
	return string(buf[:usedBufLen])
}

// ArrayToCFArray will return a CFArrayRef and if non-nil, must be released with
// Release(ref).
func ArrayToCFArray(a [] /*line :143:25*/_Ctype_CFTypeRef /*line :143:36*/)  /*line :143:38*/_Ctype_CFArrayRef /*line :143:50*/ {
	var values [] /*line :144:15*/_Ctype_uintptr_t /*line :144:26*/
	for _, value := range a {
		values = append(values,  /*line :146:27*/_Ctype_uintptr_t /*line :146:38*/(value))
	}
	numValues := len(values)
	var valuesPointer * /*line :149:21*/_Ctype_uintptr_t /*line :149:32*/
	if numValues > 0 {
		valuesPointer = &values[0]
	}
	return func() _Ctype_CFArrayRef{ var _cgo0 _Ctype_CFAllocatorRef = /*line :153:30*/*_Cvar_kCFAllocatorDefault /*line :153:51*/; var _cgo1 *_Ctype_uintptr_t = /*line :153:53*/valuesPointer; var _cgo2 _Ctype_CFIndex = _Ctype_CFIndex /*line :153:77*/(numValues); _cgoBase3 := /*line :153:90*/&*_Cvar_kCFTypeArrayCallBacks /*line :153:114*/; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :153:115*/_Cfunc_CFArrayCreateSafe2(_cgo0, _cgo1, _cgo2, _cgo3); }() //nolint
}

// CFArrayToArray converts a CFArrayRef to an array of CFTypes.
func CFArrayToArray(cfArray  /*line :157:29*/_Ctype_CFArrayRef /*line :157:41*/) (a [] /*line :157:48*/_Ctype_CFTypeRef /*line :157:59*/) {
	count := func() _Ctype_CFIndex{ var _cgo0 _Ctype_CFArrayRef = /*line :158:29*/cfArray; return /*line :158:37*/_Cfunc_CFArrayGetCount(_cgo0); }()
	if count > 0 {
		a = make([] /*line :160:14*/_Ctype_CFTypeRef /*line :160:25*/, count)
		func() { var _cgo0 _Ctype_CFArrayRef = /*line :161:22*/cfArray; var _cgo1 _Ctype_struct___1 = _Ctype_CFRange /*line :161:40*/{0, count}; _cgoIndex2 := &/*line :161:86*/a; _cgo2 := /*line :161:52*/(*unsafe.Pointer)(unsafe.Pointer(&(*_cgoIndex2)[0])); _cgoCheckPointer(_cgo2, *_cgoIndex2); /*line :161:93*/_Cfunc_CFArrayGetValues(_cgo0, _cgo1, _cgo2); }()
	}
	return
}

// Convertable knows how to convert an instance to a CFTypeRef.
type Convertable interface {
	Convert() ( /*line :168:13*/_Ctype_CFTypeRef /*line :168:24*/, error)
}

// ConvertMapToCFDictionary converts a map to a CFDictionary and if non-nil,
// must be released with Release(ref).
func ConvertMapToCFDictionary(attr map[string]interface{}) ( /*line :173:61*/_Ctype_CFDictionaryRef /*line :173:78*/, error) {
	m := make(map[ /*line :174:16*/_Ctype_CFTypeRef /*line :174:27*/] /*line :174:28*/_Ctype_CFTypeRef /*line :174:39*/)
	for key, i := range attr {
		var valueRef  /*line :176:16*/_Ctype_CFTypeRef /*line :176:27*/
		switch val := i.(type) {
		default:
			return 0, fmt.Errorf("Unsupported value type: %v", reflect.TypeOf(i))
		case  /*line :180:8*/_Ctype_CFTypeRef /*line :180:19*/:
			valueRef = val
		case bool:
			if val {
				valueRef =  /*line :184:16*/_Ctype_CFTypeRef /*line :184:27*/(( /*line :184:28*/*_Cvar_kCFBooleanTrue /*line :184:43*/))
			} else {
				valueRef =  /*line :186:16*/_Ctype_CFTypeRef /*line :186:27*/(( /*line :186:28*/*_Cvar_kCFBooleanFalse /*line :186:44*/))
			}
		case []byte:
			bytesRef, err := BytesToCFData(val)
			if err != nil {
				return 0, err
			}
			valueRef =  /*line :193:15*/_Ctype_CFTypeRef /*line :193:26*/(bytesRef)
			defer Release(valueRef)
		case string:
			stringRef, err := StringToCFString(val)
			if err != nil {
				return 0, err
			}
			valueRef =  /*line :200:15*/_Ctype_CFTypeRef /*line :200:26*/(stringRef)
			defer Release(valueRef)
		case Convertable:
			convertedRef, err := val.Convert()
			if err != nil {
				return 0, err
			}
			valueRef = convertedRef
			defer Release(valueRef)
		}
		keyRef, err := StringToCFString(key)
		if err != nil {
			return 0, err
		}
		m[ /*line :214:5*/_Ctype_CFTypeRef /*line :214:16*/(keyRef)] = valueRef
		defer Release( /*line :215:17*/_Ctype_CFTypeRef /*line :215:28*/(keyRef))
	}

	cfDict, err := MapToCFDictionary(m)
	if err != nil {
		return 0, err
	}
	return cfDict, nil
}

// CFTypeDescription returns type string for CFTypeRef.
func CFTypeDescription(ref  /*line :226:28*/_Ctype_CFTypeRef /*line :226:39*/) string {
	typeID := func() _Ctype_CFTypeID{ var _cgo0 _Ctype_CFTypeRef = /*line :227:26*/ref; return /*line :227:30*/_Cfunc_CFGetTypeID(_cgo0); }()
	typeDesc := ( /*line :228:14*/_Cfunc_CFCopyTypeIDDescription /*line :228:38*/)(typeID)
	defer Release( /*line :229:16*/_Ctype_CFTypeRef /*line :229:27*/(typeDesc))
	return CFStringToString(typeDesc)
}

// Convert converts a CFTypeRef to a go instance.
func Convert(ref  /*line :234:18*/_Ctype_CFTypeRef /*line :234:29*/) (interface{}, error) {
	typeID := func() _Ctype_CFTypeID{ var _cgo0 _Ctype_CFTypeRef = /*line :235:26*/ref; return /*line :235:30*/_Cfunc_CFGetTypeID(_cgo0); }()
	if typeID == ( /*line :236:15*/_Cfunc_CFStringGetTypeID /*line :236:33*/)() {
		return CFStringToString( /*line :237:27*/_Ctype_CFStringRef /*line :237:40*/(ref)), nil
	} else if typeID == ( /*line :238:22*/_Cfunc_CFDictionaryGetTypeID /*line :238:44*/)() {
		return ConvertCFDictionary( /*line :239:30*/_Ctype_CFDictionaryRef /*line :239:47*/(ref))
	} else if typeID == ( /*line :240:22*/_Cfunc_CFArrayGetTypeID /*line :240:39*/)() {
		arr := CFArrayToArray( /*line :241:25*/_Ctype_CFArrayRef /*line :241:37*/(ref))
		results := make([]interface{}, 0, len(arr))
		for _, ref := range arr {
			v, err := Convert(ref)
			if err != nil {
				return nil, err
			}
			results = append(results, v)
		}
		return results, nil
	} else if typeID == ( /*line :251:22*/_Cfunc_CFDataGetTypeID /*line :251:38*/)() {
		b, err := CFDataToBytes( /*line :252:27*/_Ctype_CFDataRef /*line :252:38*/(ref))
		if err != nil {
			return nil, err
		}
		return b, nil
	} else if typeID == ( /*line :257:22*/_Cfunc_CFNumberGetTypeID /*line :257:40*/)() {
		return CFNumberToInterface( /*line :258:30*/_Ctype_CFNumberRef /*line :258:43*/(ref)), nil
	} else if typeID == ( /*line :259:22*/_Cfunc_CFBooleanGetTypeID /*line :259:41*/)() {
		if func() _Ctype_Boolean{ var _cgo0 _Ctype_CFBooleanRef = _Ctype_CFBooleanRef /*line :260:40*/(ref); return /*line :260:46*/_Cfunc_CFBooleanGetValue(_cgo0); }() != 0 {
			return true, nil
		}
		return false, nil
	}

	return nil, fmt.Errorf("Invalid type: %s", CFTypeDescription(ref))
}

// ConvertCFDictionary converts a CFDictionary to map (deep).
func ConvertCFDictionary(d  /*line :270:28*/_Ctype_CFDictionaryRef /*line :270:45*/) (map[interface{}]interface{}, error) {
	m := CFDictionaryToMap(d)
	result := make(map[interface{}]interface{})

	for k, v := range m {
		gk, err := Convert(k)
		if err != nil {
			return nil, err
		}
		gv, err := Convert(v)
		if err != nil {
			return nil, err
		}
		result[gk] = gv
	}
	return result, nil
}

// CFNumberToInterface converts the CFNumberRef to the most appropriate numeric
// type.
// This code is from github.com/kballard/go-osx-plist.
func CFNumberToInterface(cfNumber  /*line :291:35*/_Ctype_CFNumberRef /*line :291:48*/) interface{} {
	typ := func() _Ctype_CFNumberType{ var _cgo0 _Ctype_CFNumberRef = /*line :292:27*/cfNumber; return /*line :292:36*/_Cfunc_CFNumberGetType(_cgo0); }()
	switch typ {
	case ( /*line :294:7*/_Ciconst_kCFNumberSInt8Type /*line :294:26*/):
		var sint  /*line :295:12*/_Ctype_SInt8 /*line :295:19*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :296:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :296:32*/typ; _cgoBase2 := /*line :296:52*/&sint; _cgo2 := /*line :296:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :296:59*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int8(sint)
	case ( /*line :298:7*/_Ciconst_kCFNumberSInt16Type /*line :298:27*/):
		var sint  /*line :299:12*/_Ctype_SInt16 /*line :299:20*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :300:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :300:32*/typ; _cgoBase2 := /*line :300:52*/&sint; _cgo2 := /*line :300:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :300:59*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int16(sint)
	case ( /*line :302:7*/_Ciconst_kCFNumberSInt32Type /*line :302:27*/):
		var sint  /*line :303:12*/_Ctype_SInt32 /*line :303:20*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :304:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :304:32*/typ; _cgoBase2 := /*line :304:52*/&sint; _cgo2 := /*line :304:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :304:59*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int32(sint)
	case ( /*line :306:7*/_Ciconst_kCFNumberSInt64Type /*line :306:27*/):
		var sint  /*line :307:12*/_Ctype_SInt64 /*line :307:20*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :308:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :308:32*/typ; _cgoBase2 := /*line :308:52*/&sint; _cgo2 := /*line :308:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :308:59*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int64(sint)
	case ( /*line :310:7*/_Ciconst_kCFNumberFloat32Type /*line :310:28*/):
		var float  /*line :311:13*/_Ctype_Float32 /*line :311:22*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :312:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :312:32*/typ; _cgoBase2 := /*line :312:52*/&float; _cgo2 := /*line :312:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :312:60*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return float32(float)
	case ( /*line :314:7*/_Ciconst_kCFNumberFloat64Type /*line :314:28*/):
		var float  /*line :315:13*/_Ctype_Float64 /*line :315:22*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :316:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :316:32*/typ; _cgoBase2 := /*line :316:52*/&float; _cgo2 := /*line :316:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :316:60*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return float64(float)
	case ( /*line :318:7*/_Ciconst_kCFNumberCharType /*line :318:25*/):
		var char  /*line :319:12*/_Ctype_char /*line :319:18*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :320:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :320:32*/typ; _cgoBase2 := /*line :320:52*/&char; _cgo2 := /*line :320:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :320:59*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return byte(char)
	case ( /*line :322:7*/_Ciconst_kCFNumberShortType /*line :322:26*/):
		var short  /*line :323:13*/_Ctype_short /*line :323:20*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :324:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :324:32*/typ; _cgoBase2 := /*line :324:52*/&short; _cgo2 := /*line :324:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :324:60*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int16(short)
	case ( /*line :326:7*/_Ciconst_kCFNumberIntType /*line :326:24*/):
		var i  /*line :327:9*/_Ctype_int /*line :327:14*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :328:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :328:32*/typ; _cgoBase2 := /*line :328:52*/&i; _cgo2 := /*line :328:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :328:56*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int32(i)
	case ( /*line :330:7*/_Ciconst_kCFNumberLongType /*line :330:25*/):
		var long  /*line :331:12*/_Ctype_long /*line :331:18*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :332:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :332:32*/typ; _cgoBase2 := /*line :332:52*/&long; _cgo2 := /*line :332:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :332:59*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int(long)
	case ( /*line :334:7*/_Ciconst_kCFNumberLongLongType /*line :334:29*/):
		// This is the only type that may actually overflow us
		var longlong  /*line :336:16*/_Ctype_longlong /*line :336:26*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :337:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :337:32*/typ; _cgoBase2 := /*line :337:52*/&longlong; _cgo2 := /*line :337:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :337:63*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int64(longlong)
	case ( /*line :339:7*/_Ciconst_kCFNumberFloatType /*line :339:26*/):
		var float  /*line :340:13*/_Ctype_float /*line :340:20*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :341:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :341:32*/typ; _cgoBase2 := /*line :341:52*/&float; _cgo2 := /*line :341:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :341:60*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return float32(float)
	case ( /*line :343:7*/_Ciconst_kCFNumberDoubleType /*line :343:27*/):
		var double  /*line :344:14*/_Ctype_double /*line :344:22*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :345:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :345:32*/typ; _cgoBase2 := /*line :345:52*/&double; _cgo2 := /*line :345:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :345:61*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return float64(double)
	case ( /*line :347:7*/_Ciconst_kCFNumberCFIndexType /*line :347:28*/):
		// CFIndex is a long
		var index  /*line :349:13*/_Ctype_CFIndex /*line :349:22*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :350:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :350:32*/typ; _cgoBase2 := /*line :350:52*/&index; _cgo2 := /*line :350:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :350:60*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int(index)
	case ( /*line :352:7*/_Ciconst_kCFNumberNSIntegerType /*line :352:30*/):
		// We don't have a definition of NSInteger, but we know it's either an int or a long
		var nsInt  /*line :354:13*/_Ctype_long /*line :354:19*/
		func() _Ctype_Boolean{ var _cgo0 _Ctype_CFNumberRef = /*line :355:22*/cfNumber; var _cgo1 _Ctype_CFNumberType = /*line :355:32*/typ; _cgoBase2 := /*line :355:52*/&nsInt; _cgo2 := /*line :355:37*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :355:60*/_Cfunc_CFNumberGetValue(_cgo0, _cgo1, _cgo2); }() //nolint
		return int(nsInt)
	}
	panic("Unknown CFNumber type")
}

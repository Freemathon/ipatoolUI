// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/februarysnow/go/pkg/mod/github.com/99designs/go-keychain@v0.0.0-20191008050251-8e49817e8af4/macos.go:1:1
// +build darwin,!ios

package keychain; import _cgo_unsafe "unsafe"

/*
#cgo LDFLAGS: -framework CoreFoundation -framework Security
#cgo CFLAGS: -w

#include <CoreFoundation/CoreFoundation.h>
#include <Security/Security.h>
*/
import _ "unsafe"
import (
	"os"
	"unsafe"
)

// AccessibleKey is key for kSecAttrAccessible
var AccessibleKey = attrKey( /*line :19:29*/_Ctype_CFTypeRef /*line :19:40*/(( /*line :19:41*/*_Cvar_kSecAttrAccessible /*line :19:60*/)))
var accessibleTypeRef = map[Accessible] /*line :20:40*/_Ctype_CFTypeRef /*line :20:51*/{
	AccessibleWhenUnlocked:                    /*line :21:44*/_Ctype_CFTypeRef /*line :21:55*/(( /*line :21:56*/*_Cvar_kSecAttrAccessibleWhenUnlocked /*line :21:87*/)),
	AccessibleAfterFirstUnlock:                /*line :22:44*/_Ctype_CFTypeRef /*line :22:55*/(( /*line :22:56*/*_Cvar_kSecAttrAccessibleAfterFirstUnlock /*line :22:91*/)),
	AccessibleAlways:                          /*line :23:44*/_Ctype_CFTypeRef /*line :23:55*/(( /*line :23:56*/*_Cvar_kSecAttrAccessibleAlways /*line :23:81*/)),
	AccessibleWhenUnlockedThisDeviceOnly:      /*line :24:44*/_Ctype_CFTypeRef /*line :24:55*/(( /*line :24:56*/*_Cvar_kSecAttrAccessibleWhenUnlockedThisDeviceOnly /*line :24:101*/)),
	AccessibleAfterFirstUnlockThisDeviceOnly:  /*line :25:44*/_Ctype_CFTypeRef /*line :25:55*/(( /*line :25:56*/*_Cvar_kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly /*line :25:105*/)),
	AccessibleAccessibleAlwaysThisDeviceOnly:  /*line :26:44*/_Ctype_CFTypeRef /*line :26:55*/(( /*line :26:56*/*_Cvar_kSecAttrAccessibleAlwaysThisDeviceOnly /*line :26:95*/)),

	// Only available in 10.10
	//AccessibleWhenPasscodeSetThisDeviceOnly:  C.CFTypeRef(C.kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly),
}

var (
	// AccessKey is key for kSecAttrAccess
	AccessKey = attrKey( /*line :34:22*/_Ctype_CFTypeRef /*line :34:33*/(( /*line :34:34*/*_Cvar_kSecAttrAccess /*line :34:49*/)))
)

// createAccess creates a SecAccessRef as CFTypeRef.
// The returned SecAccessRef, if non-nil, must be released via CFRelease.
func createAccess(label string, trustedApplications []string) ( /*line :39:64*/_Ctype_CFTypeRef /*line :39:75*/, error) {
	var err error
	var labelRef  /*line :41:15*/_Ctype_CFStringRef /*line :41:28*/
	if labelRef, err = StringToCFString(label); err != nil {
		return 0, err
	}
	defer func() func() { var _cgo0 _Ctype_CFTypeRef = _Ctype_CFTypeRef /*line :45:31*/(labelRef); return func() { /*line :45:42*/_Cfunc_CFRelease(_cgo0); }}()()

	var trustedApplicationsArray  /*line :47:31*/_Ctype_CFArrayRef /*line :47:43*/
	if trustedApplications != nil {
		if len(trustedApplications) > 0 {
			// Always prepend with empty string which signifies that we
			// include a NULL application, which means ourselves.
			trustedApplications = append([]string{""}, trustedApplications...)
		}

		var trustedApplicationsRefs [] /*line :55:33*/_Ctype_CFTypeRef /*line :55:44*/
		for _, trustedApplication := range trustedApplications {
			trustedApplicationRef, createErr := createTrustedApplication(trustedApplication)
			if createErr != nil {
				return 0, createErr
			}
			defer func() func() { var _cgo0 _Ctype_CFTypeRef = /*line :61:22*/trustedApplicationRef; return func() { /*line :61:44*/_Cfunc_CFRelease(_cgo0); }}()()
			trustedApplicationsRefs = append(trustedApplicationsRefs, trustedApplicationRef)
		}

		trustedApplicationsArray = ArrayToCFArray(trustedApplicationsRefs)
		defer func() func() { var _cgo0 _Ctype_CFTypeRef = _Ctype_CFTypeRef /*line :66:32*/(trustedApplicationsArray); return func() { /*line :66:59*/_Cfunc_CFRelease(_cgo0); }}()()
	}

	var access  /*line :69:13*/_Ctype_SecAccessRef /*line :69:27*/
	errCode := func() _Ctype_OSStatus{ var _cgo0 _Ctype_CFStringRef = /*line :70:31*/labelRef; var _cgo1 _Ctype_CFArrayRef = /*line :70:41*/trustedApplicationsArray; _cgoBase2 := /*line :70:67*/&access; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :70:75*/_Cfunc_SecAccessCreate(_cgo0, _cgo1, _cgo2); }() //nolint
	err = checkError(errCode)
	if err != nil {
		return 0, err
	}

	return  /*line :76:9*/_Ctype_CFTypeRef /*line :76:20*/(access), nil
}

// createTrustedApplication creates a SecTrustedApplicationRef as a CFTypeRef.
// The returned SecTrustedApplicationRef, if non-nil, must be released via CFRelease.
func createTrustedApplication(trustedApplication string) ( /*line :81:59*/_Ctype_CFTypeRef /*line :81:70*/, error) {
	var trustedApplicationCStr * /*line :82:30*/_Ctype_char /*line :82:36*/
	if trustedApplication != "" {
		trustedApplicationCStr = ( /*line :84:28*/_Cfunc_CString /*line :84:36*/)(trustedApplication)
		defer func() func() { _cgo0 := /*line :85:16*/unsafe.Pointer(trustedApplicationCStr); return func() { _cgoCheckPointer(_cgo0, nil); /*line :85:55*/_Cfunc_free(_cgo0); }}()()
	}

	var trustedApplicationRef  /*line :88:28*/_Ctype_SecTrustedApplicationRef /*line :88:54*/
	errCode := func() _Ctype_OSStatus{ var _cgo0 *_Ctype_char = /*line :89:51*/trustedApplicationCStr; _cgoBase1 := /*line :89:75*/&trustedApplicationRef; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :89:98*/_Cfunc_SecTrustedApplicationCreateFromPath(_cgo0, _cgo1); }() //nolint
	err := checkError(errCode)
	if err != nil {
		return 0, err
	}

	return  /*line :95:9*/_Ctype_CFTypeRef /*line :95:20*/(trustedApplicationRef), nil
}

// Access defines whats applications can use the keychain item
type Access struct {
	Label               string
	TrustedApplications []string
}

// Convert converts Access to CFTypeRef.
// The returned CFTypeRef, if non-nil, must be released via CFRelease.
func (a Access) Convert() ( /*line :106:28*/_Ctype_CFTypeRef /*line :106:39*/, error) {
	return createAccess(a.Label, a.TrustedApplications)
}

// SetAccess sets Access on Item
func (k *Item) SetAccess(a *Access) {
	if a != nil {
		k.attr[AccessKey] = a
	} else {
		delete(k.attr, AccessKey)
	}
}

// DeleteItemRef deletes a keychain item reference.
func DeleteItemRef(ref  /*line :120:24*/_Ctype_CFTypeRef /*line :120:35*/) error {
	errCode := func() _Ctype_OSStatus{ var _cgo0 _Ctype_SecKeychainItemRef = _Ctype_SecKeychainItemRef /*line :121:57*/(ref); return /*line :121:63*/_Cfunc_SecKeychainItemDelete(_cgo0); }()
	return checkError(errCode)
}

var (
	// KeychainKey is key for kSecUseKeychain
	KeychainKey = attrKey( /*line :127:24*/_Ctype_CFTypeRef /*line :127:35*/(( /*line :127:36*/*_Cvar_kSecUseKeychain /*line :127:52*/)))
	// MatchSearchListKey is key for kSecMatchSearchList
	MatchSearchListKey = attrKey( /*line :129:31*/_Ctype_CFTypeRef /*line :129:42*/(( /*line :129:43*/*_Cvar_kSecMatchSearchList /*line :129:63*/)))
)

// Keychain represents the path to a specific OSX keychain
type Keychain struct {
	path string
}

// NewKeychain creates a new keychain file with a password
func NewKeychain(path string, password string) (Keychain, error) {
	return newKeychain(path, password, false)
}

// NewKeychainWithPrompt creates a new Keychain and prompts user for password
func NewKeychainWithPrompt(path string) (Keychain, error) {
	return newKeychain(path, "", true)
}

func newKeychain(path, password string, promptUser bool) (Keychain, error) {
	pathRef := ( /*line :148:13*/_Cfunc_CString /*line :148:21*/)(path)
	defer func() func() { _cgo0 := /*line :149:15*/unsafe.Pointer(pathRef); return func() { _cgoCheckPointer(_cgo0, nil); /*line :149:39*/_Cfunc_free(_cgo0); }}()()

	var errCode  /*line :151:14*/_Ctype_OSStatus /*line :151:24*/
	var kref  /*line :152:11*/_Ctype_SecKeychainRef /*line :152:27*/

	if promptUser {
		errCode = func() _Ctype_OSStatus{ var _cgo0 *_Ctype_char = /*line :155:33*/pathRef; var _cgo1 _Ctype_UInt32 = _Ctype_UInt32 /*line :155:50*/(0); var _cgo2 _cgo_unsafe.Pointer = /*line :155:55*/nil; var _cgo3 _Ctype_Boolean = _Ctype_Boolean /*line :155:69*/(1); var _cgo4 _Ctype_SecAccessRef = /*line :155:74*/0; _cgoBase5 := /*line :155:77*/&kref; _cgo5 := _cgoBase5; _cgoCheckPointer(_cgoBase5, 0 == 0); return /*line :155:83*/_Cfunc_SecKeychainCreate(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() //nolint
	} else {
		passwordRef := ( /*line :157:18*/_Cfunc_CString /*line :157:26*/)(password)
		defer func() func() { _cgo0 := /*line :158:16*/unsafe.Pointer(passwordRef); return func() { _cgoCheckPointer(_cgo0, nil); /*line :158:44*/_Cfunc_free(_cgo0); }}()()
		errCode = func() _Ctype_OSStatus{ var _cgo0 *_Ctype_char = /*line :159:33*/pathRef; var _cgo1 _Ctype_UInt32 = _Ctype_UInt32 /*line :159:50*/(len(password)); _cgo2 := /*line :159:67*/unsafe.Pointer(passwordRef); var _cgo3 _Ctype_Boolean = _Ctype_Boolean /*line :159:105*/(0); var _cgo4 _Ctype_SecAccessRef = /*line :159:110*/0; _cgoBase5 := /*line :159:113*/&kref; _cgo5 := _cgoBase5; _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgoBase5, 0 == 0); return /*line :159:119*/_Cfunc_SecKeychainCreate(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() //nolint
	}

	if err := checkError(errCode); err != nil {
		return Keychain{}, err
	}

	// TODO: Without passing in kref I get 'One or more parameters passed to the function were not valid (-50)'
	defer Release( /*line :167:16*/_Ctype_CFTypeRef /*line :167:27*/(kref))

	return Keychain{
		path: path,
	}, nil
}

// NewWithPath to use an existing keychain
func NewWithPath(path string) Keychain {
	return Keychain{
		path: path,
	}
}

// Status returns the status of the keychain
func (kc Keychain) Status() error {
	// returns no error even if it doesn't exist
	kref, err := openKeychainRef(kc.path)
	if err != nil {
		return err
	}
	defer func() func() { var _cgo0 _Ctype_CFTypeRef = _Ctype_CFTypeRef /*line :188:31*/(kref); return func() { /*line :188:38*/_Cfunc_CFRelease(_cgo0); }}()()

	var status  /*line :190:13*/_Ctype_SecKeychainStatus /*line :190:32*/
	return checkError(func() _Ctype_OSStatus{ var _cgo0 _Ctype_SecKeychainRef = /*line :191:43*/kref; var _cgo1 *_Ctype_SecKeychainStatus = /*line :191:49*/&status; return /*line :191:57*/_Cfunc_SecKeychainGetStatus(_cgo0, _cgo1); }())
}

// The returned SecKeychainRef, if non-nil, must be released via CFRelease.
func openKeychainRef(path string) ( /*line :195:36*/_Ctype_SecKeychainRef /*line :195:52*/, error) {
	pathName := ( /*line :196:14*/_Cfunc_CString /*line :196:22*/)(path)
	defer func() func() { _cgo0 := /*line :197:15*/unsafe.Pointer(pathName); return func() { _cgoCheckPointer(_cgo0, nil); /*line :197:40*/_Cfunc_free(_cgo0); }}()()

	var kref  /*line :199:11*/_Ctype_SecKeychainRef /*line :199:27*/
	if err := checkError(func() _Ctype_OSStatus{ var _cgo0 *_Ctype_char = /*line :200:41*/pathName; _cgoBase1 := /*line :200:51*/&kref; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :200:57*/_Cfunc_SecKeychainOpen(_cgo0, _cgo1); }()); err != nil { //nolint
		return 0, err
	}

	return kref, nil
}

// UnlockAtPath unlocks keychain at path
func UnlockAtPath(path string, password string) error {
	kref, err := openKeychainRef(path)
	defer Release( /*line :210:16*/_Ctype_CFTypeRef /*line :210:27*/(kref))
	if err != nil {
		return err
	}
	passwordRef := ( /*line :214:17*/_Cfunc_CString /*line :214:25*/)(password)
	defer func() func() { _cgo0 := /*line :215:15*/unsafe.Pointer(passwordRef); return func() { _cgoCheckPointer(_cgo0, nil); /*line :215:43*/_Cfunc_free(_cgo0); }}()()
	return checkError(func() _Ctype_OSStatus{ var _cgo0 _Ctype_SecKeychainRef = /*line :216:40*/kref; var _cgo1 _Ctype_UInt32 = _Ctype_UInt32 /*line :216:54*/(len(password)); _cgo2 := /*line :216:71*/unsafe.Pointer(passwordRef); var _cgo3 _Ctype_Boolean = _Ctype_Boolean /*line :216:109*/(1); _cgoCheckPointer(_cgo2, nil); return /*line :216:113*/_Cfunc_SecKeychainUnlock(_cgo0, _cgo1, _cgo2, _cgo3); }())
}

// LockAtPath locks keychain at path
func LockAtPath(path string) error {
	kref, err := openKeychainRef(path)
	defer Release( /*line :222:16*/_Ctype_CFTypeRef /*line :222:27*/(kref))
	if err != nil {
		return err
	}
	return checkError(func() _Ctype_OSStatus{ var _cgo0 _Ctype_SecKeychainRef = /*line :226:38*/kref; return /*line :226:43*/_Cfunc_SecKeychainLock(_cgo0); }())
}

// Delete the Keychain
func (kc *Keychain) Delete() error {
	return os.Remove(kc.path)
}

// Convert Keychain to CFTypeRef.
// The returned CFTypeRef, if non-nil, must be released via CFRelease.
func (kc Keychain) Convert() ( /*line :236:31*/_Ctype_CFTypeRef /*line :236:42*/, error) {
	keyRef, err := openKeychainRef(kc.path)
	return  /*line :238:9*/_Ctype_CFTypeRef /*line :238:20*/(keyRef), err
}

type keychainArray []Keychain

// Convert the keychainArray to a CFTypeRef.
// The returned CFTypeRef, if non-nil, must be released via CFRelease.
func (ka keychainArray) Convert() ( /*line :245:36*/_Ctype_CFTypeRef /*line :245:47*/, error) {
	var refs = make([] /*line :246:20*/_Ctype_CFTypeRef /*line :246:31*/, len(ka))
	var err error

	for idx, kc := range ka {
		if refs[idx], err = kc.Convert(); err != nil {
			// If we error trying to convert lets release any we converted before
			for _, ref := range refs {
				if ref != 0 {
					Release(ref)
				}
			}
			return 0, err
		}
	}

	return  /*line :261:9*/_Ctype_CFTypeRef /*line :261:20*/(ArrayToCFArray(refs)), nil
}

// SetMatchSearchList sets match type on keychains
func (k *Item) SetMatchSearchList(karr ...Keychain) {
	k.attr[MatchSearchListKey] = keychainArray(karr)
}

// UseKeychain tells item to use the specified Keychain
func (k *Item) UseKeychain(kc Keychain) {
	k.attr[KeychainKey] = kc
}
